\documentclass[a4paper,twocolumn]{jarticle}

\input{setting.tex}

\title{{\large Distributed Scheme/分散Scheme}}
\date{}
\author{}

\headlabel{2003/11/10 須藤功平}

\begin{document}

 \maketitle

 \begin{abstract}
  プロセスを越えてSchemeオブジェクトを転送する手法を提案する．この手法で
  はリモートのSchemeオブジェクトをローカルのSchemeオブジェクトと同じよう
  に扱えるようにすることを目的とする．
 \end{abstract}

 \section{導入}
 プロセスを越えてSchemeオブジェクトを転送するには，Schemeオブジェクトを
 シリアライズ\footnote{直列化．誤解を恐れずにいえばファイルに保存できる
 ような形式にすること．}／デシリアライズ\footnote{非直列化．シリアライズ
 したものを復元すること}しなければいけない．なお，本稿では，オブジェクト
 をデータ，プログラムの総称として用いる．
 
 Schemeはデータ，プログラムともにS式として表現する．このため，プログラム
 をデータとして扱うこともデータをプログラムとして扱うことも容易である．

 リストや数値などはシリアライズ／デシリアライズできるが，手続きオブジェ
 クトはできない．本稿では，シリアライズ／デシリアライズできないオブジェ
 クトはオブジェクトへの参照を転送することによってリモートから扱えるよう
 にする．
 
 \section{構造}

 オブジェクトを公開するプロセスをサーバ，公開されているオブジェクトを利
 用するプロセスをクライアントとする．また，サーバ側で公開されているオブ
 ジェクトをリモートオブジェクト，クライアント側のオブジェクトをローカル
 オブジェクトとする．
 
 サーバはクライアントからの接続を処理するフロントオブジェクトをURIに関連
 付けてリモートオブジェクトを公開する．クライアントはURIをキーとしてフロ
 ントオブジェクトを特定する．

 クライアント側ではフロントオブジェクトを手続きで表現し，手続きを適用す
 ることによってリモートオブジェクトの値を得る．
 
 \section{例}
 
 サーバ:
 \begin{alltt}
(define front
  (make-server "dscm://localhost:6789"
    (plus (lambda (x y) (+ x y)))
    (map map)))
(add-entry! front 'lst '(1 2 3))
(serve front)
 \end{alltt}
 クライアント:
 \begin{alltt}
(define remote
  (make-server "dscm://localhost:6789"))
((remote 'plus) 1 2)
\textit{3}
(let ((x 2))
  ((remote "map") (lambda (elem) (+ elem x))
                  '(1 2)))
\textit{(3 4)}
(remote 'lst)
\textit{(1 2 3)}
 \end{alltt}
 
 \section{今後の予定}
 以上のようなものを作り，フレームワークのセッション管理，コネクションプー
 ル，モデルとビュー／コントローラの接続に使う．

 \onecolumn
 
 \section{付録: テスト駆動開発}
 テスト駆動開発では，テスト作成$\rightarrow$テスト$\rightarrow$コーディ
 ング$\rightarrow$テストというサイクルを短く繰り返す開発手法である．
 
 \subsection{例: 順列}
 GaucheとGauche用のテスティングフレームワークGaUnitを用いて順列を生成す
 る手続き\texttt{permutations}を作成する．

 まず，テストを作成する．
 \begin{alltt}(use test.unit)

(let ((test
       (make-test-suite "Permutation test suite"
         ("Permutation test case"
          ("Permutation test"
           (assert-equal '((a)) (permutations '(a))))))))
  (run test))\end{alltt}
 実行する．
 \begin{alltt}- Start test suite Permutation test suite
-- Start test case Permutation test case
E
(stdin):6: (permutations '(a))
Error occured in Permutation test
*** ERROR: unbound variable: permutations
Stack Trace:
_______________________________________
  0  (permutations '(a))
        At line 6 of "(stdin)"
  1  (asesrt-equal '((a)) (permutations '(a)))
        At line 6 of "(stdin)"
  2  (test-thunk)
        At line 45 of "/home/kou/work/gauche/gaunit/lib/test/ui/text.scm"
  3  (#<id 0x8193ec0 gauche.time::dynamic-wind> (#<id 0x8193e80 gauche. ...
        [unknown location]

1 tests, 1 assertions, 0 successes, 0 failures, 1 errors
Testing time: 5.86e-4\end{alltt}
 \texttt{permutations}を定義していないというエラーが出るのを確認し，
 テストをパスするための最小の\texttt{permutations}を定義する．
 \begin{alltt}(define (permutations lst)
  '((a)))\end{alltt}
 テストを実行する．
 \begin{alltt}- Start test suite Permutation test suite
-- Start test case Permutation test case
.
1 tests, 1 assertions, 1 successes, 0 failures, 0 errors
Testing time: 2.04e-4\end{alltt}
 今の\texttt{permutations}は今あるテストをパスするための特殊な実装なので
 テストを増やし，一般的に実装し直す．
 \begin{alltt}(let ...
           (assert-equal '((a)) (permutations '(a)))
           (assert-equal '((a b) (b a)) (permutations '(a b)))
     ...
  (run test))\end{alltt}
 テストを実行すると失敗するので，テストをパスするように
 \texttt{permutations}を実装し直す．
 \begin{alltt}(define (permutations lst)
  (if (null? (cdr lst))
      (list lst)
      (list lst (reverse lst))))\end{alltt}
 テストを実行し，パスすることを確認する．

 引数が空リストのときの動作が怪しいのでテストを追加する．
 \begin{alltt}(let ...
           (assert-equal '() (permutations '()))
           (assert-equal '((a)) (permutations '(a)))
           (assert-equal '((a b) (b a)) (permutations '(a b)))
     ...
  (run test))\end{alltt}
 テストを実行しすると，やはり失敗する．

 \texttt{permutaions}を空リストも扱えるように実装し直す．
 \begin{alltt}(define (permutations lst)
  (cond ((null? lst) '())
        ((null? (cdr lst)) (list lst))
        (else (list lst (reverse lst)))))\end{alltt}
 テストを実行し，パスすることを確認する．

 引数のリストが3要素以上のときの動作も怪しいのでテストを追加する．
 \begin{alltt}(let ...
           (assert-equal '() (permutations '()))
           (assert-equal '((a)) (permutations '(a)))
           (assert-equal '((a b) (b a)) (permutations '(a b)))
           (assert-equal '((a b c) (a c b) (b a c) (b c a) (c a b) (c b a))
                         (permutations '(a b c)))
     ...
  (run test))\end{alltt}
 テストを実行すると，失敗する．

 順列は各要素を残りの要素からなる順列の各順列の先頭に加えればできそうで
 ある．そこで，各要素毎に前の要素，対象となる要素，後ろの要素を手続きに
 渡し，返り値を\texttt{append}する\texttt{affluent-flat-map}があるとして
 \texttt{permutations}を書き直す．
 \begin{alltt}(define (permutations lst)
  (cond ((null? lst) '())
        ((null? (cdr lst)) (list lst))
        (else
         (affluent-flat-map
          (lambda (prev elem follow)
            (map (lambda (perm) (cons elem perm))
                 (permutations (append prev follow))))
          lst))))\end{alltt}
 テストを実行すると，\texttt{affluent-flat-map}が定義されていないので，
 失敗する．そこで，\texttt{affluent-flat-map}の定義する前にテストを書く．
 ここでは，\texttt{affluent-flat-map}のテストと実装のサイクルの詳細は省
 略する．
 \begin{alltt}(define (affluent-flat-map proc lst)
  (define (rec prev lst)
    (if (null? lst) '()
        (append (proc prev (car lst) (cdr lst))
                (rec (append prev (list (car lst)))
                     (cdr lst)))))
  (rec '() lst))

(let ...
          ("permutations test"
           ...
           )
          ("affluent-flat-map test"
           (define (affluent-flat-map-test lst)
             (affluent-flat-map
              (lambda (prev elem follow)
                (list prev (list elem) follow))
              lst))
           (assert-equal '() (affluent-flat-map-test '()))
           (assert-equal '(() (a) ()) (affluent-flat-map-test '(a)))
           (assert-equal '(() (a) (b) (a) (b) ())
                         (affluent-flat-map-test '(a b)))
           )
           ...
  (run test))\end{alltt}
 テストを実行すると，パスする．
  
\end{document}
